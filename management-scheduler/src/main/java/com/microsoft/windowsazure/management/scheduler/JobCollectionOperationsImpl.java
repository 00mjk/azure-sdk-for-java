// 
// Copyright (c) Microsoft and contributors.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
// 

// Warning: This code was generated by a tool.
// 
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.

package com.microsoft.windowsazure.management.scheduler;

import com.microsoft.windowsazure.management.OperationResponse;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionCheckNameAvailabilityResponse;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionCreateParameters;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionCreateResponse;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionGetResponse;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionIntrinsicSettings;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionMaxRecurrence;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionPlan;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionQuota;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionRecurrenceFrequency;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionState;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionUpdateParameters;
import com.microsoft.windowsazure.management.scheduler.models.JobCollectionUpdateResponse;
import com.microsoft.windowsazure.management.scheduler.models.SchedulerOperationStatus;
import com.microsoft.windowsazure.management.scheduler.models.SchedulerOperationStatusResponse;
import com.microsoft.windowsazure.services.core.ServiceException;
import com.microsoft.windowsazure.services.core.ServiceOperations;
import com.microsoft.windowsazure.services.core.utils.pipeline.CustomHttpDelete;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.commons.codec.binary.Base64;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.entity.StringEntity;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class JobCollectionOperationsImpl implements ServiceOperations<SchedulerManagementClientImpl>, JobCollectionOperations
{
    /**
    * Initializes a new instance of the JobCollectionOperationsImpl class.
    *
    * @param client Reference to the service client.
    */
    JobCollectionOperationsImpl(SchedulerManagementClientImpl client)
    {
        this.client = client;
    }
    
    private SchedulerManagementClientImpl client;
    
    /**
    * Gets a reference to the
    * microsoft.windowsazure.management.scheduler.SchedulerManagementClientImpl.
    */
    public SchedulerManagementClientImpl getClient() { return this.client; }
    
    /**
    * Create a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to create.
    * @param parameters Parameters supplied to the Create Job Collection
    * operation.
    * @return The Create Job Collection operation response.
    */
    @Override
    public Future<JobCollectionCreateResponse> beginCreatingAsync(final String cloudServiceName, final String jobCollectionName, final JobCollectionCreateParameters parameters)
    {
        return this.getClient().getExecutorService().submit(new Callable<JobCollectionCreateResponse>() { 
            @Override
            public JobCollectionCreateResponse call() throws Exception
            {
                return beginCreating(cloudServiceName, jobCollectionName, parameters);
            }
         });
    }
    
    /**
    * Create a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to create.
    * @param parameters Parameters supplied to the Create Job Collection
    * operation.
    * @return The Create Job Collection operation response.
    */
    @Override
    public JobCollectionCreateResponse beginCreating(String cloudServiceName, String jobCollectionName, JobCollectionCreateParameters parameters) throws ParserConfigurationException, SAXException, TransformerConfigurationException, TransformerException, UnsupportedEncodingException, IOException, ServiceException
    {
        // Validate
        if (cloudServiceName == null)
        {
            throw new NullPointerException("cloudServiceName");
        }
        if (jobCollectionName == null)
        {
            throw new NullPointerException("jobCollectionName");
        }
        if (jobCollectionName.length() > 100)
        {
            throw new IllegalArgumentException("jobCollectionName");
        }
        if (parameters == null)
        {
            throw new NullPointerException("parameters");
        }
        
        // Tracing
        
        // Construct URL
        String url = this.getClient().getBaseUri() + this.getClient().getCredentials().getSubscriptionId() + "/cloudservices/" + cloudServiceName + "/resources/" + "scheduler" + "/" + "JobCollections" + "/" + jobCollectionName;
        
        // Create HTTP transport objects
        HttpPut httpRequest = new HttpPut(url);
        
        // Set Headers
        httpRequest.setHeader("Content-Type", "application/xml");
        httpRequest.setHeader("x-ms-version", "2013-03-01");
        
        // Serialize Request
        String requestContent = null;
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document requestDoc = documentBuilder.newDocument();
        
        Element resourceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Resource");
        requestDoc.appendChild(resourceElement);
        
        if (parameters.getSchemaVersion() != null)
        {
            Element schemaVersionElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "SchemaVersion");
            schemaVersionElement.appendChild(requestDoc.createTextNode(parameters.getSchemaVersion()));
            resourceElement.appendChild(schemaVersionElement);
        }
        
        if (parameters.getLabel() != null)
        {
            Element labelElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Label");
            labelElement.appendChild(requestDoc.createTextNode(new String(Base64.encodeBase64(parameters.getLabel().getBytes()))));
            resourceElement.appendChild(labelElement);
        }
        
        if (parameters.getIntrinsicSettings() != null)
        {
            Element intrinsicSettingsElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "IntrinsicSettings");
            resourceElement.appendChild(intrinsicSettingsElement);
            
            Element planElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Plan");
            planElement.appendChild(requestDoc.createTextNode(parameters.getIntrinsicSettings().getPlan().toString()));
            intrinsicSettingsElement.appendChild(planElement);
            
            if (parameters.getIntrinsicSettings().getQuota() != null)
            {
                Element quotaElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Quota");
                intrinsicSettingsElement.appendChild(quotaElement);
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxJobCount() != null)
                {
                    Element maxJobCountElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxJobCount");
                    maxJobCountElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxJobCount())));
                    quotaElement.appendChild(maxJobCountElement);
                }
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxJobOccurrence() != null)
                {
                    Element maxJobOccurrenceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxJobOccurrence");
                    maxJobOccurrenceElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxJobOccurrence())));
                    quotaElement.appendChild(maxJobOccurrenceElement);
                }
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxRecurrence() != null)
                {
                    Element maxRecurrenceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxRecurrence");
                    quotaElement.appendChild(maxRecurrenceElement);
                    
                    Element frequencyElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Frequency");
                    frequencyElement.appendChild(requestDoc.createTextNode(parameters.getIntrinsicSettings().getQuota().getMaxRecurrence().getFrequency().toString()));
                    maxRecurrenceElement.appendChild(frequencyElement);
                    
                    Element intervalElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Interval");
                    intervalElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxRecurrence().getInterval())));
                    maxRecurrenceElement.appendChild(intervalElement);
                }
            }
        }
        
        DOMSource domSource = new DOMSource(requestDoc);
        StringWriter stringWriter = new StringWriter();
        StreamResult streamResult = new StreamResult(stringWriter);
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(domSource, streamResult);
        requestContent = stringWriter.toString();
        StringEntity entity = new StringEntity(requestContent);
        httpRequest.setEntity(entity);
        httpRequest.setHeader("Content-Type", "application/xml");
        
        // Send Request
        HttpResponse httpResponse = null;
        httpResponse = this.getClient().getHttpClient().execute(httpRequest);
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode != 202)
        {
            ServiceException ex = ServiceException.createFromXml(httpRequest, requestContent, httpResponse, httpResponse.getEntity());
            throw ex;
        }
        
        // Create Result
        JobCollectionCreateResponse result = null;
        result = new JobCollectionCreateResponse();
        result.setStatusCode(statusCode);
        if (httpResponse.getHeaders("ETag").length > 0)
        {
            result.setETag(httpResponse.getFirstHeader("ETag").getValue());
        }
        if (httpResponse.getHeaders("x-ms-request-id").length > 0)
        {
            result.setRequestId(httpResponse.getFirstHeader("x-ms-request-id").getValue());
        }
        
        return result;
    }
    
    /**
    * Deletes a job collection
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName The name of the job collection to delete.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public Future<OperationResponse> beginDeletingAsync(final String cloudServiceName, final String jobCollectionName)
    {
        return this.getClient().getExecutorService().submit(new Callable<OperationResponse>() { 
            @Override
            public OperationResponse call() throws Exception
            {
                return beginDeleting(cloudServiceName, jobCollectionName);
            }
         });
    }
    
    /**
    * Deletes a job collection
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName The name of the job collection to delete.
    * @return A standard service response including an HTTP status code and
    * request ID.
    */
    @Override
    public OperationResponse beginDeleting(String cloudServiceName, String jobCollectionName) throws IOException, ServiceException
    {
        // Validate
        if (cloudServiceName == null)
        {
            throw new NullPointerException("cloudServiceName");
        }
        if (jobCollectionName == null)
        {
            throw new NullPointerException("jobCollectionName");
        }
        
        // Tracing
        
        // Construct URL
        String url = this.getClient().getBaseUri() + this.getClient().getCredentials().getSubscriptionId() + "/cloudservices/" + cloudServiceName + "/resources/" + "scheduler" + "/" + "JobCollections" + "/" + jobCollectionName;
        
        // Create HTTP transport objects
        CustomHttpDelete httpRequest = new CustomHttpDelete(url);
        
        // Set Headers
        httpRequest.setHeader("x-ms-version", "2013-03-01");
        
        // Send Request
        HttpResponse httpResponse = null;
        httpResponse = this.getClient().getHttpClient().execute(httpRequest);
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode != 202)
        {
            ServiceException ex = ServiceException.createFromXml(httpRequest, null, httpResponse, httpResponse.getEntity());
            throw ex;
        }
        
        // Create Result
        OperationResponse result = null;
        result = new OperationResponse();
        result.setStatusCode(statusCode);
        if (httpResponse.getHeaders("x-ms-request-id").length > 0)
        {
            result.setRequestId(httpResponse.getFirstHeader("x-ms-request-id").getValue());
        }
        
        return result;
    }
    
    /**
    * Update a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to update.
    * @param parameters Parameters supplied to the Update Job Collection
    * operation.
    * @return The Update Job Collection operation response.
    */
    @Override
    public Future<JobCollectionUpdateResponse> beginUpdatingAsync(final String cloudServiceName, final String jobCollectionName, final JobCollectionUpdateParameters parameters)
    {
        return this.getClient().getExecutorService().submit(new Callable<JobCollectionUpdateResponse>() { 
            @Override
            public JobCollectionUpdateResponse call() throws Exception
            {
                return beginUpdating(cloudServiceName, jobCollectionName, parameters);
            }
         });
    }
    
    /**
    * Update a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to update.
    * @param parameters Parameters supplied to the Update Job Collection
    * operation.
    * @return The Update Job Collection operation response.
    */
    @Override
    public JobCollectionUpdateResponse beginUpdating(String cloudServiceName, String jobCollectionName, JobCollectionUpdateParameters parameters) throws ParserConfigurationException, SAXException, TransformerConfigurationException, TransformerException, UnsupportedEncodingException, IOException, ServiceException
    {
        // Validate
        if (cloudServiceName == null)
        {
            throw new NullPointerException("cloudServiceName");
        }
        if (jobCollectionName == null)
        {
            throw new NullPointerException("jobCollectionName");
        }
        if (jobCollectionName.length() > 100)
        {
            throw new IllegalArgumentException("jobCollectionName");
        }
        if (parameters == null)
        {
            throw new NullPointerException("parameters");
        }
        if (parameters.getETag() == null)
        {
            throw new NullPointerException("parameters.ETag");
        }
        
        // Tracing
        
        // Construct URL
        String url = this.getClient().getBaseUri() + this.getClient().getCredentials().getSubscriptionId() + "/cloudservices/" + cloudServiceName + "/resources/" + "scheduler" + "/" + "JobCollections" + "/" + jobCollectionName;
        
        // Create HTTP transport objects
        HttpPut httpRequest = new HttpPut(url);
        
        // Set Headers
        httpRequest.setHeader("Content-Type", "application/xml");
        httpRequest.setHeader("If-Match", parameters.getETag());
        httpRequest.setHeader("x-ms-version", "2013-03-01");
        
        // Serialize Request
        String requestContent = null;
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document requestDoc = documentBuilder.newDocument();
        
        Element resourceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Resource");
        requestDoc.appendChild(resourceElement);
        
        if (parameters.getSchemaVersion() != null)
        {
            Element schemaVersionElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "SchemaVersion");
            schemaVersionElement.appendChild(requestDoc.createTextNode(parameters.getSchemaVersion()));
            resourceElement.appendChild(schemaVersionElement);
        }
        
        if (parameters.getLabel() != null)
        {
            Element labelElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Label");
            labelElement.appendChild(requestDoc.createTextNode(new String(Base64.encodeBase64(parameters.getLabel().getBytes()))));
            resourceElement.appendChild(labelElement);
        }
        
        if (parameters.getIntrinsicSettings() != null)
        {
            Element intrinsicSettingsElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "IntrinsicSettings");
            resourceElement.appendChild(intrinsicSettingsElement);
            
            Element planElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Plan");
            planElement.appendChild(requestDoc.createTextNode(parameters.getIntrinsicSettings().getPlan().toString()));
            intrinsicSettingsElement.appendChild(planElement);
            
            if (parameters.getIntrinsicSettings().getQuota() != null)
            {
                Element quotaElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Quota");
                intrinsicSettingsElement.appendChild(quotaElement);
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxJobCount() != null)
                {
                    Element maxJobCountElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxJobCount");
                    maxJobCountElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxJobCount())));
                    quotaElement.appendChild(maxJobCountElement);
                }
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxJobOccurrence() != null)
                {
                    Element maxJobOccurrenceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxJobOccurrence");
                    maxJobOccurrenceElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxJobOccurrence())));
                    quotaElement.appendChild(maxJobOccurrenceElement);
                }
                
                if (parameters.getIntrinsicSettings().getQuota().getMaxRecurrence() != null)
                {
                    Element maxRecurrenceElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "MaxRecurrence");
                    quotaElement.appendChild(maxRecurrenceElement);
                    
                    Element frequencyElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Frequency");
                    frequencyElement.appendChild(requestDoc.createTextNode(parameters.getIntrinsicSettings().getQuota().getMaxRecurrence().getFrequency().toString()));
                    maxRecurrenceElement.appendChild(frequencyElement);
                    
                    Element intervalElement = requestDoc.createElementNS("http://schemas.microsoft.com/windowsazure", "Interval");
                    intervalElement.appendChild(requestDoc.createTextNode(Integer.toString(parameters.getIntrinsicSettings().getQuota().getMaxRecurrence().getInterval())));
                    maxRecurrenceElement.appendChild(intervalElement);
                }
            }
        }
        
        DOMSource domSource = new DOMSource(requestDoc);
        StringWriter stringWriter = new StringWriter();
        StreamResult streamResult = new StreamResult(stringWriter);
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(domSource, streamResult);
        requestContent = stringWriter.toString();
        StringEntity entity = new StringEntity(requestContent);
        httpRequest.setEntity(entity);
        httpRequest.setHeader("Content-Type", "application/xml");
        
        // Send Request
        HttpResponse httpResponse = null;
        httpResponse = this.getClient().getHttpClient().execute(httpRequest);
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode != 202)
        {
            ServiceException ex = ServiceException.createFromXml(httpRequest, requestContent, httpResponse, httpResponse.getEntity());
            throw ex;
        }
        
        // Create Result
        JobCollectionUpdateResponse result = null;
        result = new JobCollectionUpdateResponse();
        result.setStatusCode(statusCode);
        if (httpResponse.getHeaders("ETag").length > 0)
        {
            result.setETag(httpResponse.getFirstHeader("ETag").getValue());
        }
        if (httpResponse.getHeaders("x-ms-request-id").length > 0)
        {
            result.setRequestId(httpResponse.getFirstHeader("x-ms-request-id").getValue());
        }
        
        return result;
    }
    
    /**
    * Determine if the JobCollection name is available to be used.
    * JobCollection names must be unique within a cloud-service.
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName A name for the JobCollection. The name must be
    * unique as scoped within the CloudService.  The name can be up to 100
    * characters in length.
    * @return The Check Name Availability operation response.
    */
    @Override
    public Future<JobCollectionCheckNameAvailabilityResponse> checkNameAvailabilityAsync(final String cloudServiceName, final String jobCollectionName)
    {
        return this.getClient().getExecutorService().submit(new Callable<JobCollectionCheckNameAvailabilityResponse>() { 
            @Override
            public JobCollectionCheckNameAvailabilityResponse call() throws Exception
            {
                return checkNameAvailability(cloudServiceName, jobCollectionName);
            }
         });
    }
    
    /**
    * Determine if the JobCollection name is available to be used.
    * JobCollection names must be unique within a cloud-service.
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName A name for the JobCollection. The name must be
    * unique as scoped within the CloudService.  The name can be up to 100
    * characters in length.
    * @return The Check Name Availability operation response.
    */
    @Override
    public JobCollectionCheckNameAvailabilityResponse checkNameAvailability(String cloudServiceName, String jobCollectionName) throws IOException, ServiceException, ParserConfigurationException, SAXException
    {
        // Validate
        if (cloudServiceName == null)
        {
            throw new NullPointerException("cloudServiceName");
        }
        if (jobCollectionName == null)
        {
            throw new NullPointerException("jobCollectionName");
        }
        if (jobCollectionName.length() > 100)
        {
            throw new IllegalArgumentException("jobCollectionName");
        }
        
        // Tracing
        
        // Construct URL
        String url = this.getClient().getBaseUri() + this.getClient().getCredentials().getSubscriptionId() + "/cloudservices/" + cloudServiceName + "/resources/" + "scheduler" + "/" + "JobCollections" + "/?op=checknameavailability&resourceName=" + jobCollectionName;
        
        // Create HTTP transport objects
        HttpGet httpRequest = new HttpGet(url);
        
        // Set Headers
        httpRequest.setHeader("x-ms-version", "2013-03-01");
        
        // Send Request
        HttpResponse httpResponse = null;
        httpResponse = this.getClient().getHttpClient().execute(httpRequest);
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode != 200)
        {
            ServiceException ex = ServiceException.createFromXml(httpRequest, null, httpResponse, httpResponse.getEntity());
            throw ex;
        }
        
        // Create Result
        JobCollectionCheckNameAvailabilityResponse result = null;
        // Deserialize Response
        InputStream responseContent = httpResponse.getEntity().getContent();
        result = new JobCollectionCheckNameAvailabilityResponse();
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document responseDoc = documentBuilder.parse(responseContent);
        
        NodeList elements = responseDoc.getElementsByTagName("ResourceNameAvailabilityResponse");
        Element resourceNameAvailabilityResponseElement = elements.getLength() > 0 ? ((Element)elements.item(0)) : null;
        if (resourceNameAvailabilityResponseElement != null)
        {
            NodeList elements2 = resourceNameAvailabilityResponseElement.getElementsByTagName("IsAvailable");
            Element isAvailableElement = elements2.getLength() > 0 ? ((Element)elements2.item(0)) : null;
            if (isAvailableElement != null)
            {
                boolean isAvailableInstance;
                isAvailableInstance = Boolean.parseBoolean(isAvailableElement.getTextContent());
                result.setIsAvailable(isAvailableInstance);
            }
        }
        
        result.setStatusCode(statusCode);
        if (httpResponse.getHeaders("x-ms-request-id").length > 0)
        {
            result.setRequestId(httpResponse.getFirstHeader("x-ms-request-id").getValue());
        }
        
        return result;
    }
    
    /**
    * Create a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to create.
    * @param parameters Parameters supplied to the Create Job Collection
    * operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<SchedulerOperationStatusResponse> createAsync(final String cloudServiceName, final String jobCollectionName, final JobCollectionCreateParameters parameters)
    {
        return this.getClient().getExecutorService().submit(new Callable<SchedulerOperationStatusResponse>() { 
            @Override
            public SchedulerOperationStatusResponse call() throws Exception
            {
                return create(cloudServiceName, jobCollectionName, parameters);
            }
         });
    }
    
    /**
    * Create a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to create.
    * @param parameters Parameters supplied to the Create Job Collection
    * operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public SchedulerOperationStatusResponse create(String cloudServiceName, String jobCollectionName, JobCollectionCreateParameters parameters) throws InterruptedException, ExecutionException, ServiceException
    {
        SchedulerManagementClient client2 = this.getClient();
        
        JobCollectionCreateResponse response = client2.getJobCollections().beginCreatingAsync(cloudServiceName, jobCollectionName, parameters).get();
        SchedulerOperationStatusResponse result = client2.getOperationStatusAsync(response.getRequestId()).get();
        int delayInSeconds = 15;
        while ((result.getStatus() != SchedulerOperationStatus.InProgress) == false)
        {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getOperationStatusAsync(response.getRequestId()).get();
            delayInSeconds = 10;
        }
        
        if (result.getStatus() != SchedulerOperationStatus.Succeeded)
        {
            ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
            ex.setErrorCode(result.getError().getCode());
            ex.setErrorMessage(result.getError().getMessage());
            throw ex;
        }
        
        result.setETag(response.getETag());
        return result;
    }
    
    /**
    * Deletes a job collection
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName The name of the job collection to delete.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<SchedulerOperationStatusResponse> deleteAsync(final String cloudServiceName, final String jobCollectionName)
    {
        return this.getClient().getExecutorService().submit(new Callable<SchedulerOperationStatusResponse>() { 
            @Override
            public SchedulerOperationStatusResponse call() throws Exception
            {
                return delete(cloudServiceName, jobCollectionName);
            }
         });
    }
    
    /**
    * Deletes a job collection
    *
    * @param cloudServiceName The name of the cloud service.
    * @param jobCollectionName The name of the job collection to delete.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public SchedulerOperationStatusResponse delete(String cloudServiceName, String jobCollectionName) throws InterruptedException, ExecutionException, ServiceException
    {
        SchedulerManagementClient client2 = this.getClient();
        
        OperationResponse response = client2.getJobCollections().beginDeletingAsync(cloudServiceName, jobCollectionName).get();
        SchedulerOperationStatusResponse result = client2.getOperationStatusAsync(response.getRequestId()).get();
        int delayInSeconds = 15;
        while ((result.getStatus() != SchedulerOperationStatus.InProgress) == false)
        {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getOperationStatusAsync(response.getRequestId()).get();
            delayInSeconds = 10;
        }
        
        if (result.getStatus() != SchedulerOperationStatus.Succeeded)
        {
            ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
            ex.setErrorCode(result.getError().getCode());
            ex.setErrorMessage(result.getError().getMessage());
            throw ex;
        }
        
        return result;
    }
    
    /**
    * Retreive a job collection.
    *
    * @param cloudServiceName Name of the cloud service.
    * @param jobCollectionName Name of the job collection.
    * @return The Get Job Collection operation response.
    */
    @Override
    public Future<JobCollectionGetResponse> getAsync(final String cloudServiceName, final String jobCollectionName)
    {
        return this.getClient().getExecutorService().submit(new Callable<JobCollectionGetResponse>() { 
            @Override
            public JobCollectionGetResponse call() throws Exception
            {
                return get(cloudServiceName, jobCollectionName);
            }
         });
    }
    
    /**
    * Retreive a job collection.
    *
    * @param cloudServiceName Name of the cloud service.
    * @param jobCollectionName Name of the job collection.
    * @return The Get Job Collection operation response.
    */
    @Override
    public JobCollectionGetResponse get(String cloudServiceName, String jobCollectionName) throws IOException, ServiceException, ParserConfigurationException, SAXException
    {
        // Validate
        if (cloudServiceName == null)
        {
            throw new NullPointerException("cloudServiceName");
        }
        if (jobCollectionName == null)
        {
            throw new NullPointerException("jobCollectionName");
        }
        
        // Tracing
        
        // Construct URL
        String url = this.getClient().getBaseUri() + this.getClient().getCredentials().getSubscriptionId() + "/cloudservices/" + cloudServiceName + "/resources/" + "scheduler" + "/~/" + "JobCollections" + "/" + jobCollectionName;
        
        // Create HTTP transport objects
        HttpGet httpRequest = new HttpGet(url);
        
        // Set Headers
        httpRequest.setHeader("x-ms-version", "2013-03-01");
        
        // Send Request
        HttpResponse httpResponse = null;
        httpResponse = this.getClient().getHttpClient().execute(httpRequest);
        int statusCode = httpResponse.getStatusLine().getStatusCode();
        if (statusCode != 200)
        {
            ServiceException ex = ServiceException.createFromXml(httpRequest, null, httpResponse, httpResponse.getEntity());
            throw ex;
        }
        
        // Create Result
        JobCollectionGetResponse result = null;
        // Deserialize Response
        InputStream responseContent = httpResponse.getEntity().getContent();
        result = new JobCollectionGetResponse();
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
        Document responseDoc = documentBuilder.parse(responseContent);
        
        NodeList elements = responseDoc.getElementsByTagName("Resource");
        Element resourceElement = elements.getLength() > 0 ? ((Element)elements.item(0)) : null;
        if (resourceElement != null)
        {
            NodeList elements2 = resourceElement.getElementsByTagName("Name");
            Element nameElement = elements2.getLength() > 0 ? ((Element)elements2.item(0)) : null;
            if (nameElement != null)
            {
                String nameInstance;
                nameInstance = nameElement.getTextContent();
                result.setName(nameInstance);
            }
            
            NodeList elements3 = resourceElement.getElementsByTagName("ETag");
            Element eTagElement = elements3.getLength() > 0 ? ((Element)elements3.item(0)) : null;
            if (eTagElement != null)
            {
                String eTagInstance;
                eTagInstance = eTagElement.getTextContent();
                result.setETag(eTagInstance);
            }
            
            NodeList elements4 = resourceElement.getElementsByTagName("State");
            Element stateElement = elements4.getLength() > 0 ? ((Element)elements4.item(0)) : null;
            if (stateElement != null)
            {
                JobCollectionState stateInstance;
                stateInstance = JobCollectionState.valueOf(stateElement.getTextContent());
                result.setState(stateInstance);
            }
            
            NodeList elements5 = resourceElement.getElementsByTagName("SchemaVersion");
            Element schemaVersionElement = elements5.getLength() > 0 ? ((Element)elements5.item(0)) : null;
            if (schemaVersionElement != null)
            {
                String schemaVersionInstance;
                schemaVersionInstance = schemaVersionElement.getTextContent();
                result.setSchemaVersion(schemaVersionInstance);
            }
            
            NodeList elements6 = resourceElement.getElementsByTagName("Plan");
            Element planElement = elements6.getLength() > 0 ? ((Element)elements6.item(0)) : null;
            if (planElement != null)
            {
                String planInstance;
                planInstance = planElement.getTextContent();
                result.setPlan(planInstance);
            }
            
            NodeList elements7 = resourceElement.getElementsByTagName("PromotionCode");
            Element promotionCodeElement = elements7.getLength() > 0 ? ((Element)elements7.item(0)) : null;
            if (promotionCodeElement != null)
            {
                String promotionCodeInstance;
                promotionCodeInstance = promotionCodeElement.getTextContent();
                result.setPromotionCode(promotionCodeInstance);
            }
            
            NodeList elements8 = resourceElement.getElementsByTagName("IntrinsicSettings");
            Element intrinsicSettingsElement = elements8.getLength() > 0 ? ((Element)elements8.item(0)) : null;
            if (intrinsicSettingsElement != null)
            {
                JobCollectionIntrinsicSettings intrinsicSettingsInstance = new JobCollectionIntrinsicSettings();
                result.setIntrinsicSettings(intrinsicSettingsInstance);
                
                NodeList elements9 = intrinsicSettingsElement.getElementsByTagName("Plan");
                Element planElement2 = elements9.getLength() > 0 ? ((Element)elements9.item(0)) : null;
                if (planElement2 != null)
                {
                    JobCollectionPlan planInstance2;
                    planInstance2 = JobCollectionPlan.valueOf(planElement2.getTextContent());
                    intrinsicSettingsInstance.setPlan(planInstance2);
                }
                
                NodeList elements10 = intrinsicSettingsElement.getElementsByTagName("Quota");
                Element quotaElement = elements10.getLength() > 0 ? ((Element)elements10.item(0)) : null;
                if (quotaElement != null)
                {
                    JobCollectionQuota quotaInstance = new JobCollectionQuota();
                    intrinsicSettingsInstance.setQuota(quotaInstance);
                    
                    NodeList elements11 = quotaElement.getElementsByTagName("MaxJobCount");
                    Element maxJobCountElement = elements11.getLength() > 0 ? ((Element)elements11.item(0)) : null;
                    if (maxJobCountElement != null && (maxJobCountElement.getTextContent() != null && maxJobCountElement.getTextContent().isEmpty() != true) == false)
                    {
                        int maxJobCountInstance;
                        maxJobCountInstance = Integer.parseInt(maxJobCountElement.getTextContent());
                        quotaInstance.setMaxJobCount(maxJobCountInstance);
                    }
                    
                    NodeList elements12 = quotaElement.getElementsByTagName("MaxJobOccurrence");
                    Element maxJobOccurrenceElement = elements12.getLength() > 0 ? ((Element)elements12.item(0)) : null;
                    if (maxJobOccurrenceElement != null && (maxJobOccurrenceElement.getTextContent() != null && maxJobOccurrenceElement.getTextContent().isEmpty() != true) == false)
                    {
                        int maxJobOccurrenceInstance;
                        maxJobOccurrenceInstance = Integer.parseInt(maxJobOccurrenceElement.getTextContent());
                        quotaInstance.setMaxJobOccurrence(maxJobOccurrenceInstance);
                    }
                    
                    NodeList elements13 = quotaElement.getElementsByTagName("MaxRecurrence");
                    Element maxRecurrenceElement = elements13.getLength() > 0 ? ((Element)elements13.item(0)) : null;
                    if (maxRecurrenceElement != null)
                    {
                        JobCollectionMaxRecurrence maxRecurrenceInstance = new JobCollectionMaxRecurrence();
                        quotaInstance.setMaxRecurrence(maxRecurrenceInstance);
                        
                        NodeList elements14 = maxRecurrenceElement.getElementsByTagName("Frequency");
                        Element frequencyElement = elements14.getLength() > 0 ? ((Element)elements14.item(0)) : null;
                        if (frequencyElement != null)
                        {
                            JobCollectionRecurrenceFrequency frequencyInstance;
                            frequencyInstance = JobCollectionRecurrenceFrequency.valueOf(frequencyElement.getTextContent());
                            maxRecurrenceInstance.setFrequency(frequencyInstance);
                        }
                        
                        NodeList elements15 = maxRecurrenceElement.getElementsByTagName("Interval");
                        Element intervalElement = elements15.getLength() > 0 ? ((Element)elements15.item(0)) : null;
                        if (intervalElement != null)
                        {
                            int intervalInstance;
                            intervalInstance = Integer.parseInt(intervalElement.getTextContent());
                            maxRecurrenceInstance.setInterval(intervalInstance);
                        }
                    }
                }
            }
            
            NodeList elements16 = resourceElement.getElementsByTagName("Label");
            Element labelElement = elements16.getLength() > 0 ? ((Element)elements16.item(0)) : null;
            if (labelElement != null)
            {
                String labelInstance;
                labelInstance = labelElement.getTextContent() != null ? new String(Base64.decodeBase64(labelElement.getTextContent().getBytes())) : null;
                result.setLabel(labelInstance);
            }
            
            NodeList elements17 = resourceElement.getElementsByTagName("CloudServiceSettings");
            Element cloudServiceSettingsElement = elements17.getLength() > 0 ? ((Element)elements17.item(0)) : null;
            if (cloudServiceSettingsElement != null)
            {
                JobCollectionGetResponse.CloudServiceSettingInfo cloudServiceSettingsInstance = new JobCollectionGetResponse.CloudServiceSettingInfo();
                result.setCloudServiceSettings(cloudServiceSettingsInstance);
                
                NodeList elements18 = cloudServiceSettingsElement.getElementsByTagName("GeoRegion");
                Element geoRegionElement = elements18.getLength() > 0 ? ((Element)elements18.item(0)) : null;
                if (geoRegionElement != null)
                {
                    String geoRegionInstance;
                    geoRegionInstance = geoRegionElement.getTextContent();
                    cloudServiceSettingsInstance.setGeoRegion(geoRegionInstance);
                }
            }
            
            NodeList elements19 = resourceElement.getElementsByTagName("OperationStatus");
            Element operationStatusElement = elements19.getLength() > 0 ? ((Element)elements19.item(0)) : null;
            if (operationStatusElement != null)
            {
                JobCollectionGetResponse.OperationStatus operationStatusInstance = new JobCollectionGetResponse.OperationStatus();
                result.setLastOperationStatus(operationStatusInstance);
                
                NodeList elements20 = operationStatusElement.getElementsByTagName("Error");
                Element errorElement = elements20.getLength() > 0 ? ((Element)elements20.item(0)) : null;
                if (errorElement != null)
                {
                    JobCollectionGetResponse.OperationStatusResponseDetails errorInstance = new JobCollectionGetResponse.OperationStatusResponseDetails();
                    operationStatusInstance.setResponseDetails(errorInstance);
                    
                    NodeList elements21 = errorElement.getElementsByTagName("HttpCode");
                    Element httpCodeElement = elements21.getLength() > 0 ? ((Element)elements21.item(0)) : null;
                    if (httpCodeElement != null)
                    {
                        Integer httpCodeInstance;
                        httpCodeInstance = Integer.valueOf(httpCodeElement.getTextContent());
                        errorInstance.setStatusCode(httpCodeInstance);
                    }
                    
                    NodeList elements22 = errorElement.getElementsByTagName("Message");
                    Element messageElement = elements22.getLength() > 0 ? ((Element)elements22.item(0)) : null;
                    if (messageElement != null)
                    {
                        String messageInstance;
                        messageInstance = messageElement.getTextContent();
                        errorInstance.setMessage(messageInstance);
                    }
                }
                
                NodeList elements23 = operationStatusElement.getElementsByTagName("Result");
                Element resultElement = elements23.getLength() > 0 ? ((Element)elements23.item(0)) : null;
                if (resultElement != null)
                {
                    SchedulerOperationStatus resultInstance;
                    resultInstance = SchedulerOperationStatus.valueOf(resultElement.getTextContent());
                    operationStatusInstance.setStatus(resultInstance);
                }
            }
        }
        
        result.setStatusCode(statusCode);
        if (httpResponse.getHeaders("x-ms-request-id").length > 0)
        {
            result.setRequestId(httpResponse.getFirstHeader("x-ms-request-id").getValue());
        }
        
        return result;
    }
    
    /**
    * Update a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to update.
    * @param parameters Parameters supplied to the Update Job Collection
    * operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public Future<SchedulerOperationStatusResponse> updateAsync(final String cloudServiceName, final String jobCollectionName, final JobCollectionUpdateParameters parameters)
    {
        return this.getClient().getExecutorService().submit(new Callable<SchedulerOperationStatusResponse>() { 
            @Override
            public SchedulerOperationStatusResponse call() throws Exception
            {
                return update(cloudServiceName, jobCollectionName, parameters);
            }
         });
    }
    
    /**
    * Update a job collection.
    *
    * @param cloudServiceName The name of the cloud service containing the job
    * collection.
    * @param jobCollectionName The name of the job collection to update.
    * @param parameters Parameters supplied to the Update Job Collection
    * operation.
    * @return The response body contains the status of the specified
    * asynchronous operation, indicating whether it has succeeded, is
    * inprogress, or has failed. Note that this status is distinct from the
    * HTTP status code returned for the Get Operation Status operation itself.
    * If the asynchronous operation succeeded, the response body includes the
    * HTTP status code for the successful request.  If the asynchronous
    * operation failed, the response body includes the HTTP status code for
    * the failed request, and also includes error information regarding the
    * failure.
    */
    @Override
    public SchedulerOperationStatusResponse update(String cloudServiceName, String jobCollectionName, JobCollectionUpdateParameters parameters) throws InterruptedException, ExecutionException, ServiceException
    {
        SchedulerManagementClient client2 = this.getClient();
        
        JobCollectionUpdateResponse response = client2.getJobCollections().beginUpdatingAsync(cloudServiceName, jobCollectionName, parameters).get();
        SchedulerOperationStatusResponse result = client2.getOperationStatusAsync(response.getRequestId()).get();
        int delayInSeconds = 15;
        while ((result.getStatus() != SchedulerOperationStatus.InProgress) == false)
        {
            Thread.sleep(delayInSeconds * 1000);
            result = client2.getOperationStatusAsync(response.getRequestId()).get();
            delayInSeconds = 10;
        }
        
        if (result.getStatus() != SchedulerOperationStatus.Succeeded)
        {
            ServiceException ex = new ServiceException(result.getError().getCode() + " : " + result.getError().getMessage());
            ex.setErrorCode(result.getError().getCode());
            ex.setErrorMessage(result.getError().getMessage());
            throw ex;
        }
        
        result.setETag(response.getETag());
        return result;
    }
}
